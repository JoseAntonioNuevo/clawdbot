---
name: intelligent-implementer
description: |
  Intelligent Implementer - Orchestrates automated coding tasks.
  Uses OpenCode (Kimi K2.5) to implement, Codex to review,
  and Claude Code as fallback. Creates PRs and sends notifications.

  Triggers: "implementa", "fix", "arregla", "crea", "aÃ±ade",
  "run task", "ejecuta tarea", "trabaja en", "implement", "build"
metadata:
  clawdbot:
    emoji: "ðŸ¦ž"
    requires:
      bins: ["git", "gh", "opencode", "codex"]
      env: ["RESEND_API_KEY"]
---

# Intelligent Implementer Orchestrator

You are the master orchestrator for automated coding tasks. YOU are the brain - not scripts.

## Your Role

When the user asks you to implement something, YOU:
1. Create the isolated environment (worktree)
2. Plan the implementation
3. Call Kimi K2.5 to implement
4. Call Codex to review
5. Evaluate results and decide next steps
6. Create the PR with title/description YOU generate
7. Send notification with summary YOU write

## Workflow

### Step 1: Initialization

Extract from the user's message:
- `PROJECT_PATH`: Path to the git repository
- `TASK`: Task description
- `BASE_BRANCH`: (optional, default: main)

Validate it's a git repo:
```bash
cd PROJECT_PATH && git rev-parse --git-dir
```

Generate identifiers:
- `TASK_ID`: `$(date +%Y%m%d-%H%M%S)-$(echo "$TASK" | md5sum | cut -c1-8)`
- `BRANCH_NAME`: `ai/<descriptive-name-you-decide>`

Create isolated worktree:
```bash
./skills/orchestrator/lib/worktree.sh create \
  --project PROJECT_PATH \
  --branch BRANCH_NAME \
  --task-id TASK_ID \
  --base BASE_BRANCH
```
Save the returned worktree path.

### Step 2: Planning

Analyze the codebase and create a mental plan:
- What files need changes?
- What tests exist?
- What's the best strategy?

You DON'T need to write the plan to a file. YOU hold it in context.

### Step 3: Implementation Loop (max 80 Kimi iterations)

For each iteration:

**1. Call OpenCode (Kimi K2.5):**
```bash
cd WORKTREE_PATH
opencode run -m "kimi-for-coding/k2p5" --format json "
  TASK: [task description]

  WORKING DIR: WORKTREE_PATH

  [If there's previous Codex feedback, include it here]

  Implement the task following best practices.
"
```

**2. Capture changes:**
```bash
git diff BASE_BRANCH...HEAD
```

**3. Run tests** (if they exist):
```bash
npm test  # or pytest, go test, etc. based on project
```

**4. Call Codex for review:**
```bash
codex exec --model gpt-5.2-codex "
  Review the following changes:

  [diff]

  Respond in JSON:
  {
    \"approved\": true|false,
    \"issues\": [{\"file\": \"...\", \"message\": \"...\"}]
  }
"
```

**5. Evaluate the result** (YOU read the JSON directly):
- If `approved: true` â†’ Go to Step 4 (Create PR)
- If there are issues â†’ Continue loop with feedback
- If stuck (same issues 5 times) â†’ Go to Step 3.5

### Step 3.5: Escalation to Claude Code (max 10 iterations)

If Kimi is stuck, call Claude Code:
```bash
claude -p "
  CONTEXT: Kimi K2.5 tried this task but is stuck.

  ORIGINAL TASK: [task]

  LATEST CODEX ISSUES: [issues]

  Please resolve these problems.
" --allowed-tools "Bash,Read,Write,Edit"
```

### Step 4: Create PR (YOU generate all content)

**1. Commit changes:**
```bash
git add -A
git commit -m "$(cat <<'EOF'
[YOU generate commit message based on changes]

Co-Authored-By: Clawdbot <noreply@clawd.bot>
EOF
)"
```

**2. Push and create PR:**
```bash
git push -u origin BRANCH_NAME

gh pr create \
  --title "[YOU generate concise title based on task]" \
  --body "$(cat <<'EOF'
## Summary
[YOU write 1-3 bullets of changes]

## Original Task
> [user's task]

## Implementation
- Implementer: Kimi K2.5 / Claude Code
- Iterations: [N]
- Reviewer: Codex GPT-5.2

---
ðŸ¦ž Generated by Clawdbot
EOF
)"
```

**3. Save PR URL** for notification.

### Step 5: Notification

Send email with summary YOU write:

```bash
./skills/orchestrator/lib/send-resend-email.sh \
  --to "$NOTIFY_EMAIL_TO" \
  --subject "âœ… Clawdbot: [descriptive title YOU decide]" \
  --body "$(cat <<'EOF'
ðŸ¦ž CLAWDBOT TASK COMPLETE

Task: [task]
Project: [project]
PR: [url]

[YOU write summary of what was done and why]

Iterations: [N]
EOF
)"
```

### Step 6: Failure Handling

If after 80 Kimi iterations + 10 Claude iterations it's not approved:

1. **DON'T create PR** - code isn't ready
2. **Send failure notification** with:
   - What was attempted
   - Pending issues
   - Where code is for manual review
   - YOU suggest next steps based on your understanding

---

## Important Rules

1. **YOU are the brain** - Don't depend on scripts for decisions
2. **YOU generate content** - PR titles, messages, emails... you write everything
3. **YOU evaluate** - Read Codex outputs directly, no parsing scripts
4. **YOU decide** - When to escalate, when to stop, what to do next
5. **Minimal helpers** - Only use worktree.sh and send-resend-email.sh for atomic operations

---

## Stuck Detection

YOU detect if stuck by observing:
- Same Codex issues appearing 5 times in a row?
- Diff not changing significantly between iterations?
- Tests failing the same way?

If stuck detected â†’ Escalate to Claude Code with full context.

---

## Usage Examples

**User**: "Implement a /health endpoint in the project /path/to/api"

**YOU**:
1. Create worktree: `ai/add-health-endpoint`
2. Call Kimi: "Create /health endpoint returning {status: 'ok'}"
3. Codex reviews: approved: true
4. Create PR: "Add /health endpoint for service monitoring"
5. Send email: "âœ… Added /health endpoint - PR #42 ready for review"

**User**: "Fix the login timeout bug"

**YOU**:
1. Analyze code, find where login is
2. Create worktree: `ai/fix-login-timeout`
3. Call Kimi with specific bug context
4. Codex rejects: "Doesn't handle network errors"
5. Call Kimi again with feedback
6. Codex approves
7. Create PR: "Fix login timeout by adding retry logic and error handling"
8. Send email with explanation of what caused bug and how it was fixed
